import type { IconNames } from "@nypl/design-system-react-components"
import type { Patron, SierraPatron } from "../../../types/myAccountTypes"

import { buildPatron } from "../../../utils/myAccountUtils"
import { filteredPickupLocations } from "../../../../__test__/fixtures/processedMyAccountData"

type Phone = { number: string; type: string }
type PhoneOrEmail = string | Phone

export const getLibraryByCode = (code) =>
  filteredPickupLocations.find((loc) => loc.code.trim() === code.trim())

export const accountSettings = [
  {
    field: "phones",
    icon: "communicationCall",
    term: "Phone",
    description: (value: Phone[]) => value[0]?.number,
  },
  {
    field: "emails",
    icon: "communicationEmail",
    term: "Email",
    description: (value: string[]) => value[0],
  },
  {
    field: "notificationPreference",
    icon: "communicationChatBubble",
    term: "Notification preference",
  },
  {
    field: "homeLibraryCode",
    icon: "actionHome",
    term: "Home library",
    description: (code) => getLibraryByCode(code)?.name,
  },
  {
    field: "pin",
    icon: "actionLockClosed",
    term: "Pin/Password",
    description: (_) => "****",
  },
] as {
  field: string
  icon: IconNames
  term: string
  description?: (any) => string
}[]

export const updateArrayValue = (
  newPrimary: PhoneOrEmail,
  currentValues: PhoneOrEmail[]
) => {
  const removedNewPrimaryIfPresent = currentValues.filter((val) => {
    if (val["type"]) return val["number"] !== newPrimary["number"]
    return val !== newPrimary
  })
  return [newPrimary, ...removedNewPrimaryIfPresent]
}

export const updatePhonesArray = (newValues, currentValues: Phone[]) => {
  newValues = [
    { number: newValues[0], type: "t" },
    { number: newValues[1], type: "t" },
  ]
  let newPrimary = currentValues[0]
  let newSecondary = currentValues[1]

  if (newValues[0]?.number !== currentValues[0]?.number) {
    newPrimary = newValues[0]
  }
  if (newValues[1]?.number !== currentValues[1]?.number) {
    newSecondary = newValues[1]
  }

  return [newPrimary, newSecondary, ...currentValues]
}

/** Parses the account settings form submission event target and turns it into
 * the payload for the patron settings update request.
 */

export const parsePayload = (formSubmissionBody, settingsData: Patron) => {
  console.log(formSubmissionBody)
  return accountSettings.reduce((putRequestPayload, setting) => {
    const field = setting.field
    const fieldValue =
      field === "phones"
        ? [
            formSubmissionBody[field][0]?.value,
            formSubmissionBody[field][1]?.value,
          ]
        : formSubmissionBody[field]?.value
    if (!fieldValue) {
      return putRequestPayload
    }
    switch (field) {
      case "pin":
        // pin is handled in a separate dialog
        break
      case "emails":
        putRequestPayload["emails"] = updateArrayValue(
          fieldValue,
          settingsData.emails
        ) as string[]
        break
      case "phones":
        putRequestPayload["phones"] = updatePhonesArray(
          fieldValue,
          settingsData.phones
        ) as Phone[]
        break
      case "notificationPreference":
        putRequestPayload["fixedFields"] = {
          "268": {
            label: "Notice Preference",
            value: fieldValue,
          },
        }
        break
      case "homeLibraryCode":
        putRequestPayload.homeLibraryCode = fieldValue
    }
    console.log(putRequestPayload)
    return putRequestPayload
  }, {} as SierraPatron)
}

// Combines original patron state with the payload generated by parsePayload
// so the account settings display can update without a data refresh.
export const updatePatronData = (
  originalPatronData: Patron,
  patronUpdateBody: SierraPatron
) => {
  const newData = buildPatron(patronUpdateBody)
  Object.keys(originalPatronData).forEach((setting) => {
    if (!newData[setting] || !newData[setting].length)
      newData[setting] = originalPatronData[setting]
  })
  return newData
}
